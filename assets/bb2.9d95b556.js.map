{"version":3,"file":"bb2.9d95b556.js","sources":["../../bb2/texture.jpg","../../bb2/r2.png","../../bb2/b2.png","../../bb2/noise.frag","../../bb2/noise.vert","../../bb2/main.js"],"sourcesContent":["export default \"__VITE_ASSET__fb0f5fdc__\"","export default \"__VITE_ASSET__dee41ee3__\"","export default \"__VITE_ASSET__0dc69ad7__\"","export const shader = `\r\nvarying vec2 vUv;\r\nuniform float uTime;\r\nuniform vec2 uResolution;\r\nuniform float scaleUp;\r\nvarying float noise;\r\nuniform sampler2D alphaMap;\r\n\r\n\r\nfloat map(float value, float min1, float max1, float min2, float max2) {\r\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\r\n}\r\n\r\nvec2 skew (vec2 st, float a1, float a2) {\r\n    vec2 r = vec2(0.0);\r\n    r.x = a1 * st.x;\r\n    r.y = st.y + a2 *r.x;\r\n    return r;\r\n}\r\n\r\nfloat random (vec2 st) {\r\n    return fract(sin(dot(st.xy,\r\n                         vec2(12.9898,78.233)))*\r\n        43758.5453123);\r\n}\r\n\r\nfloat aastep (float threshold, float dist) {\r\n  float afwidth = fwidth(dist) * 0.5;\r\n  return smoothstep(threshold - afwidth, threshold + afwidth, dist);\r\n}\r\n\r\nvoid main() {\r\n    vec2 inp = vec2(vUv.x,vUv.y + uTime * 0.1 ) * 5.0;\r\n\r\n    float scale = 16.0;\r\n    vec2 coord = gl_FragCoord.xy;\r\n\r\n    \r\n    vec2 p = vUv * scaleUp;\r\n  \r\n  \r\n    \r\n    vec2 f = fract(p);\r\n    vec3 bgColor = vec3(.0,.0,.1);\r\n\r\n    float size = .01;\r\n    float mixval = 1.0;\r\n    vec3 wireColor = vec3(0.0,1.0,1.0);\r\n\r\n    mixval *= aastep(size, f.x);\r\n    mixval *= aastep(size, f.y);\r\n    mixval *= aastep(size, abs(f.x-f.y));\r\n\r\n    vec3 fc = mix(wireColor, bgColor, mixval);\r\n\r\n\r\n    // add red line middle\r\n    vec3 lc = vec3(1.0,0.2,0.2);\r\n    \r\n    float distort = (0.05+noise * .100);\r\n    float lp = .5 + sin(vUv.y * 4. + uTime) * 0.1 * distort;\r\n    \r\n    float lw = 0.005;\r\n    \r\n\r\n  // mix the line color\r\n    lc = mix(vec3(0.0,.5,0.3),lc, noise * .2);\r\n\r\n\r\n    // generate the line\r\n    // start painting\r\n    float mixlc  = step(lp, vUv.x) ;\r\n    // and remove painting\r\n    mixlc -= step(lp +lw, vUv.x);\r\n\r\n    float a2 = texture2D(alphaMap, vUv).r;\r\n\r\n    \r\n    fc = mix(fc, lc, mixlc);\r\n    gl_FragColor = vec4(fc,a2);\r\n    \r\n}\r\n`;\r\n","export const shader = `\r\nvarying vec2 vUv;\r\nvarying float noise;\r\n\r\nuniform float uTime;\r\n// uniform vec2 iResolution;\r\n// uniform vec2 iMouse;\r\n// uniform float audio1;\r\n// uniform sampler2D iChannel0;\r\n// uniform sampler2D iChannel1;\r\n \r\n//\r\n// GLSL textureless classic 3D noise \"cnoise\",\r\n// with an RSL-style periodic variant \"pnoise\".\r\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\r\n// Version: 2011-10-11\r\n//\r\n// Many thanks to Ian McEwan of Ashima Arts for the\r\n// ideas for permutation and gradient selection.\r\n//\r\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\r\n// Distributed under the MIT license. See LICENSE file.\r\n// https://github.com/stegu/webgl-noise\r\n//\r\n\r\nvec3 mod289(vec3 x)\r\n{\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 mod289(vec4 x)\r\n{\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 permute(vec4 x)\r\n{\r\n  return mod289(((x*34.0)+10.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(vec4 r)\r\n{\r\n  return 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nvec3 fade(vec3 t) {\r\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\r\n}\r\n\r\n// Classic Perlin noise\r\nfloat cnoise(vec3 P)\r\n{\r\n  vec3 Pi0 = floor(P); // Integer part for indexing\r\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\r\n  Pi0 = mod289(Pi0);\r\n  Pi1 = mod289(Pi1);\r\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n  vec4 iz0 = Pi0.zzzz;\r\n  vec4 iz1 = Pi1.zzzz;\r\n\r\n  vec4 ixy = permute(permute(ix) + iy);\r\n  vec4 ixy0 = permute(ixy + iz0);\r\n  vec4 ixy1 = permute(ixy + iz1);\r\n\r\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\r\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n  gx0 = fract(gx0);\r\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n  vec4 sz0 = step(gz0, vec4(0.0));\r\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\r\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n  gx1 = fract(gx1);\r\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n  vec4 sz1 = step(gz1, vec4(0.0));\r\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n\r\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n  g000 *= norm0.x;\r\n  g010 *= norm0.y;\r\n  g100 *= norm0.z;\r\n  g110 *= norm0.w;\r\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n  g001 *= norm1.x;\r\n  g011 *= norm1.y;\r\n  g101 *= norm1.z;\r\n  g111 *= norm1.w;\r\n\r\n  float n000 = dot(g000, Pf0);\r\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n  float n111 = dot(g111, Pf1);\r\n\r\n  vec3 fade_xyz = fade(Pf0);\r\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \r\n  return 2.2 * n_xyz;\r\n}\r\n\r\n// Classic Perlin noise, periodic variant\r\nfloat pnoise(vec3 P, vec3 rep)\r\n{\r\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\r\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\r\n  Pi0 = mod289(Pi0);\r\n  Pi1 = mod289(Pi1);\r\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n  vec4 iz0 = Pi0.zzzz;\r\n  vec4 iz1 = Pi1.zzzz;\r\n\r\n  vec4 ixy = permute(permute(ix) + iy);\r\n  vec4 ixy0 = permute(ixy + iz0);\r\n  vec4 ixy1 = permute(ixy + iz1);\r\n\r\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\r\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n  gx0 = fract(gx0);\r\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n  vec4 sz0 = step(gz0, vec4(0.0));\r\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\r\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n  gx1 = fract(gx1);\r\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n  vec4 sz1 = step(gz1, vec4(0.0));\r\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n\r\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n  g000 *= norm0.x;\r\n  g010 *= norm0.y;\r\n  g100 *= norm0.z;\r\n  g110 *= norm0.w;\r\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n  g001 *= norm1.x;\r\n  g011 *= norm1.y;\r\n  g101 *= norm1.z;\r\n  g111 *= norm1.w;\r\n\r\n  float n000 = dot(g000, Pf0);\r\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n  float n111 = dot(g111, Pf1);\r\n\r\n  vec3 fade_xyz = fade(Pf0);\r\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \r\n  return 2.2 * n_xyz;\r\n}\r\n\r\nfloat turbulence( vec3 p ) {\r\n\r\n  float w = 100.0;\r\n  float t = -.5;\r\n\r\n  for (float f = 1.0 ; f <= 10.0 ; f++ ){\r\n    float power = pow( 2.0, f );\r\n    t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );\r\n  }\r\n\r\n  return t;\r\n\r\n}\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n\r\n  float offset = uTime * .2;\r\n\r\n  // get a turbulent 3d noise using the normal, normal to high freq\r\n  //noise = 10.0 *  -.50 * turbulence( .5 * normal );\r\n  // get a 3d noise using the position, low frequency\r\n  float b = 25.0 * pnoise( 4.0 * vec3(uv.x,uv.y + offset, 1.0), vec3( 100.0 ) );\r\n  noise = b;\r\n  // compose both noises\r\n  //float displacement = - 10. * noise;\r\n\r\n  vec4 mvPosition = modelViewMatrix * vec4(position, 2.0 );\r\n\r\n    //gl_PointSize = 2. +(500. * uTime ) * (1. / -mvPosition.z);\r\n    //vec3 newPos = position  * displacement;\r\n    //newPos.z = displacement;\r\n  //gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);\r\n  \r\n  vec2 suv = vUv;\r\n  mvPosition.y -= b * 1.1;\r\n  \r\n  gl_Position = projectionMatrix * mvPosition;\r\n  //gl_Position.z = sin(uv.y);\r\n  //gl_Position.x += sin(uTime) * 0.1;\r\n}`;","import \"./style.css\";\r\n\r\n//import './style.css'\r\nimport * as THREE from \"three\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\n//import '../shared/OrbitControls.js'\r\nimport * as dat from \"dat.gui\";\r\n\r\nimport textureUrl from \"./texture.jpg\";\r\nimport displacementUrl from \"./r2.png\";\r\nimport alphaUrl from \"./b2.png\";\r\n\r\nimport { shader as frag } from \"./noise.frag\"\r\nimport { shader as vertex } from \"./noise.vert\"\r\n\r\nconst loader = new THREE.TextureLoader();\r\nconst texture = loader.load(textureUrl);\r\nconst displacement = loader.load(displacementUrl);\r\nconst alphaMap = loader.load(alphaUrl);\r\n\r\n// Debug\r\nconst gui = new dat.GUI();\r\n\r\nlet config = {\r\n  color: \"#00d1ff\",\r\n  light: {\r\n    x: 0,\r\n    y: 0,\r\n    z: 0,\r\n  },\r\n  reactToMouse: false,\r\n};\r\n\r\n// gui.add(config, \"reactToMouse\")\r\n\r\n// Canvas\r\nconst canvas = document.querySelector(\"canvas\");\r\n\r\n// Scene\r\nconst scene = new THREE.Scene();\r\n\r\n// Objects\r\nlet gsize = 16 * 12;\r\nconst scaleUp = 64.0;\r\nconst geometry = new THREE.PlaneBufferGeometry(gsize,gsize, scaleUp,scaleUp);\r\n\r\n// Materials\r\nconst material = new THREE.ShaderMaterial({\r\n//   color: \"red\",\r\n  // map: texture,\r\n  // displacementMap: displacement,\r\n  // displacementScale: .7,\r\n  // alphaMap: alphaMap,\r\n  //wireframe: true,\r\n  \r\n  uniforms: {\r\n    uTime: { value: 0.0 },\r\n    uResolution: { type: \"v2\", value: new THREE.Vector2() },\r\n    alphaMap: { type: \"t\", value: alphaMap },\r\n    scaleUp: { value: scaleUp },\r\n  },\r\n  transparent: true,\r\n  depthTest: false,\r\n  fragmentShader: frag,\r\n  vertexShader: vertex,\r\n  alphaMap\r\n\r\n});\r\nmaterial.uniforms.uResolution.value.x = window.innerWidth;\r\nmaterial.uniforms.uResolution.value.y = window.innerHeight;\r\n\r\n\r\n\r\n// Mesh\r\nconst plane = new THREE.Mesh(geometry, material);\r\nplane.rotation.x = 181;\r\nplane.position.z = 2;\r\nscene.add(plane);\r\n// gui.add(plane.material, \"displacementScale\",0,5)\r\n\r\n// Lights\r\n\r\n// const pointLight = new THREE.PointLight(config.color, 2)\r\n// pointLight.position.x = 2\r\n// pointLight.position.y = 3\r\n// pointLight.position.z = 4\r\n// scene.add(pointLight)\r\n\r\n// const f = gui.addFolder(\"Light\", true)\r\n// f.add(pointLight.position,'x',-100,100);\r\n// f.add(pointLight.position,'y',-100,100);\r\n// f.add(pointLight.position,'z',-100,100);\r\n// f.add(pointLight, 'intensity', 0, 10);\r\n\r\n// gui.addColor(config,'color').onChange((c) =>{\r\n//     pointLight.color.set(config.color)\r\n// })\r\n\r\n/**\r\n * Sizes\r\n */\r\nconst sizes = {\r\n  width: window.innerWidth,\r\n  height: window.innerHeight,\r\n};\r\n\r\nwindow.addEventListener(\"resize\", () => {\r\n  // Update sizes\r\n  sizes.width = window.innerWidth;\r\n  sizes.height = window.innerHeight;\r\n\r\n  // Update camera\r\n  camera.aspect = sizes.width / sizes.height;\r\n  camera.updateProjectionMatrix();\r\n\r\n  // Update renderer\r\n  renderer.setSize(sizes.width, sizes.height);\r\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n});\r\n\r\n/**\r\n * Camera\r\n */\r\n// Base camera\r\nconst camera = new THREE.PerspectiveCamera(\r\n  75,\r\n  sizes.width / sizes.height,\r\n  1,\r\n  3000\r\n);\r\ncamera.position.x = 0;\r\ncamera.position.y = 1;\r\ncamera.position.z = 25;\r\nscene.add(camera);\r\n\r\n// Controls\r\n// const controls = new OrbitControls(camera, canvas)\r\n// controls.enableDamping = true\r\n\r\n/**\r\n * Renderer\r\n */\r\nconst renderer = new THREE.WebGLRenderer({\r\n  canvas: canvas,\r\n  antialias: true\r\n});\r\nrenderer.setSize(sizes.width, sizes.height);\r\nrenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n\r\nconst controls = new OrbitControls(camera, renderer.domElement);\r\ncontrols.enableDamping = true;\r\n//controls.autoRotate = true;\r\n/**\r\n * Animate\r\n */\r\n\r\n// document.addEventListener(\"mousemove\", mousemove);\r\n// let mouseY =0\r\n\r\n// function mousemove(event) {\r\n//     mouseY = event.clientY / sizes.height;\r\n// }\r\n\r\nconst clock = new THREE.Clock();\r\n\r\nconst tick = () => {\r\n  const elapsedTime = clock.getElapsedTime();\r\n  plane.material.uniforms.uTime.value = elapsedTime;\r\n\r\n  // Update objects\r\n  //plane.rotation.z = .5 * elapsedTime\r\n  //pointLight.position.x = 1 + 3 * mouseY\r\n//   if (config.reactToMouse) {\r\n//     plane.material.displacementScale = 0.4 + 0.1 * (1 - mouseY);\r\n//   }\r\n  // Update Orbital Controls\r\n  controls.update();\r\n\r\n  // Render\r\n  renderer.render(scene, camera);\r\n\r\n  // Call tick again on the next frame\r\n  window.requestAnimationFrame(tick);\r\n};\r\n\r\ntick();\r\n"],"names":["shader","THREE.TextureLoader","dat.GUI","THREE.Scene","THREE.PlaneBufferGeometry","THREE.ShaderMaterial","THREE.Vector2","frag","vertex","THREE.Mesh","THREE.PerspectiveCamera","THREE.WebGLRenderer","THREE.Clock"],"mappings":"uJAAA,MAAe,6CCAA,wCCAA,sCCAR,KAAMA,GAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAT,EAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCehB,EAAS,GAAIC,GACH,EAAO,KAAK,GACP,EAAO,KAAK,GACjC,KAAM,GAAW,EAAO,KAAK,GAGjB,GAAIC,GAehB,KAAM,GAAS,SAAS,cAAc,UAGhC,EAAQ,GAAIC,GAGlB,GAAI,GAAQ,GAAK,GACjB,KAAM,GAAU,GACV,EAAW,GAAIC,GAA0B,EAAM,EAAO,EAAQ,GAG9D,EAAW,GAAIC,GAAqB,CAQxC,SAAU,CACR,MAAO,CAAE,MAAO,GAChB,YAAa,CAAE,KAAM,KAAM,MAAO,GAAIC,IACtC,SAAU,CAAE,KAAM,IAAK,MAAO,GAC9B,QAAS,CAAE,MAAO,IAEpB,YAAa,GACb,UAAW,GACX,eAAgBC,EAChB,aAAcC,EACd,aAGF,EAAS,SAAS,YAAY,MAAM,EAAI,OAAO,WAC/C,EAAS,SAAS,YAAY,MAAM,EAAI,OAAO,YAK/C,KAAM,GAAQ,GAAIC,GAAW,EAAU,GACvC,EAAM,SAAS,EAAI,IACnB,EAAM,SAAS,EAAI,EACnB,EAAM,IAAI,GAwBV,KAAM,GAAQ,CACZ,MAAO,OAAO,WACd,OAAQ,OAAO,aAGjB,OAAO,iBAAiB,SAAU,IAAM,CAEtC,EAAM,MAAQ,OAAO,WACrB,EAAM,OAAS,OAAO,YAGtB,EAAO,OAAS,EAAM,MAAQ,EAAM,OACpC,EAAO,yBAGP,EAAS,QAAQ,EAAM,MAAO,EAAM,QACpC,EAAS,cAAc,KAAK,IAAI,OAAO,iBAAkB,MAO3D,KAAM,GAAS,GAAIC,GACjB,GACA,EAAM,MAAQ,EAAM,OACpB,EACA,KAEF,EAAO,SAAS,EAAI,EACpB,EAAO,SAAS,EAAI,EACpB,EAAO,SAAS,EAAI,GACpB,EAAM,IAAI,GASV,KAAM,GAAW,GAAIC,GAAoB,CACvC,OAAQ,EACR,UAAW,KAEb,EAAS,QAAQ,EAAM,MAAO,EAAM,QACpC,EAAS,cAAc,KAAK,IAAI,OAAO,iBAAkB,IAEzD,KAAM,GAAW,GAAI,GAAc,EAAQ,EAAS,YACpD,EAAS,cAAgB,GAazB,KAAM,GAAQ,GAAIC,GAEZ,EAAO,IAAM,CACjB,KAAM,GAAc,EAAM,iBAC1B,EAAM,SAAS,SAAS,MAAM,MAAQ,EAStC,EAAS,SAGT,EAAS,OAAO,EAAO,GAGvB,OAAO,sBAAsB,IAG/B"}