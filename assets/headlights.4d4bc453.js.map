{"version":3,"file":"headlights.4d4bc453.js","sources":["../../headlights/BasicThreeDemo.js","../../headlights/CarLights.js","../../headlights/Road.js","../../headlights/effects.js","../../headlights/main.js"],"sourcesContent":["import * as THREE from \"three\";\r\n\r\n// import * as Stats from \"stats.js\";\r\n// var stats = new Stats();\r\n// document.body.appendChild( stats.dom );\r\n// stats.showPanel(0);\r\n\r\nexport class BasicThreeDemo {\r\n    constructor(container) {\r\n      this.container = container;\r\n      this.renderer = new THREE.WebGLRenderer({\r\n        antialias: true\r\n      });\r\n      this.renderer.setSize(container.offsetWidth, container.offsetHeight, false);\r\n      this.renderer.setPixelRatio(window.devicePixelRatio);\r\n  \r\n      container.append(this.renderer.domElement);\r\n  \r\n      this.camera = new THREE.PerspectiveCamera(\r\n        45,\r\n        container.offsetWidth / container.offsetHeight,\r\n        0.1,\r\n        10000\r\n      );\r\n      this.scene = new THREE.Scene();\r\n  \r\n      this.clock = new THREE.Clock();\r\n      this.assets = {};\r\n      this.disposed = false;\r\n      this.tick = this.tick.bind(this);\r\n      this.init = this.init.bind(this);\r\n    }\r\n    loadAssets() {\r\n      return new Promise((resolve, reject) => {\r\n        // const manager = new THREE.LoadingManager(resolve);\r\n        // this.text.load(manager);\r\n      });\r\n    }\r\n    init() {\r\n      this.tick();\r\n    }\r\n    getViewSizeAtDepth(depth = 0) {\r\n      const fovInRadians = (this.camera.fov * Math.PI) / 180;\r\n      const height = Math.abs(\r\n        (this.camera.position.z - depth) * Math.tan(fovInRadians / 2) * 2\r\n      );\r\n      return { width: height * this.camera.aspect, height };\r\n    }\r\n    dispose() {\r\n      this.disposed = true;\r\n    }\r\n    onResize() {}\r\n    update() {}\r\n    render() {\r\n      this.renderer.render(this.scene, this.camera);\r\n    }\r\n    tick() {\r\n      if (this.disposed) return;\r\n      //stats.begin()\r\n      if (resizeRendererToDisplaySize(this.renderer)) {\r\n        const canvas = this.renderer.domElement;\r\n        this.camera.aspect = canvas.clientWidth / canvas.clientHeight;\r\n        this.camera.updateProjectionMatrix();\r\n        this.onResize();\r\n      }\r\n      const delta = this.clock.getDelta();\r\n      this.render(delta);\r\n      this.update(delta);\r\n      //stats.end()\r\n      requestAnimationFrame(this.tick);\r\n    }\r\n  }\r\n  \r\n  function resizeRendererToDisplaySize(renderer) {\r\n    const canvas = renderer.domElement;\r\n    const width = canvas.clientWidth;\r\n    const height = canvas.clientHeight;\r\n    const needResize = canvas.width !== width || canvas.height !== height;\r\n    if (needResize) {\r\n      renderer.setSize(width, height, false);\r\n    }\r\n    return needResize;\r\n  }","import * as THREE from \"three\";\r\nconst pickRandom = arr => {\r\n    if (Array.isArray(arr)) return arr[Math.floor(Math.random() * arr.length)];\r\n    return arr;\r\n  };\r\nexport class CarLights {\r\n  constructor(app, options) {\r\n    this.app = app;\r\n    this.options = options;\r\n\r\n    this.fragmentShader = `\r\n    #include <fog_pars_fragment>\r\n    uniform vec3 uColor;\r\n      varying vec2 vUv;\r\n      uniform float uSpeed;\r\n      varying float vprogress;\r\n      uniform float uTime;\r\n      varying vec3 vColors;\r\n\r\n\r\n      void main(){\r\n          \r\n          float d = step(0.0, uSpeed);\r\n          float alpha = smoothstep(1.0 - d, d + .0, vUv.x);\r\n\r\n        //   vec3 color1 = vec3(0.984,0.773,0.043);\r\n        //   vec3 color2 = vec3(0.871,0.365,0.);\r\n        //   float mixValue = distance(vUv.x,vec2(0,1));\r\n        //   vec3 color = mix(color1,color2,mixValue);\r\n\r\n\r\n            vec3 color = vColors;\r\n        //color *= 1.5 + sin(vprogress * 90. + uTime );\r\n\r\n          alpha *= smoothstep(0.,.2, 1.-vprogress);\r\n          gl_FragColor = vec4(color,alpha);\r\n          if (gl_FragColor.a < 0.0001) discard;\r\n          \r\n\r\n      }\r\n  `;\r\n    this.vertexShader = `\r\n    #include <fog_pars_vertex>\r\n\r\n    uniform float uTime;\r\n\r\n    #include <getDistortion_vertex>\r\n    uniform float uSpeed;\r\n    uniform float uTravelLength;\r\n    varying vec2 vUv;\r\n    varying float vprogress;\r\n    varying vec3 vColors;\r\n    attribute vec3 aOffset;\r\n    attribute vec3 aColors;\r\n    attribute vec2 aMetrics;\r\n      void main() {\r\n        #include <begin_vertex>\r\n        #include <project_vertex>\r\n        #include <fog_vertex>\r\n        vUv = uv;\r\n        \r\n        float radius = aMetrics.r;\r\n            float len = aMetrics.g;\r\n            vColors = aColors;\r\n\r\n          \r\n\r\n        // set the radius and length\r\n        transformed.xy *= radius;\r\n        transformed.z *= len;\r\n\r\n        // Keep them separated to make the next step easier!\r\n        float zOffset = uTime * uSpeed + aOffset.z;\r\n        zOffset = len - mod(zOffset, uTravelLength);\r\n        transformed.z += zOffset;\r\n        transformed.xy += aOffset.xy;\r\n\r\n        float progress = abs(transformed.z / uTravelLength);\r\n        vprogress = progress;\r\n        transformed.xyz += getDistortion(progress);\r\n        \r\n    \r\n        mvPosition = modelViewMatrix * vec4(transformed,1.);\r\n        gl_Position = projectionMatrix * mvPosition;\r\n        //gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.);\r\n\r\n\r\n      }\r\n  `;\r\n  }\r\n\r\n  init() {\r\n    const options = this.options;\r\n    let curve = new THREE.LineCurve3(\r\n      new THREE.Vector3(0, 0, 0),\r\n      new THREE.Vector3(0, 0, -1)\r\n    );\r\n\r\n    let baseGeometry = new THREE.TubeBufferGeometry(curve, 20, 2, 8, false);\r\n    let instancedGeometry = new THREE.InstancedBufferGeometry().copy(\r\n      baseGeometry\r\n    );\r\n    instancedGeometry.instanceCount = options.nPairs * 2;\r\n    //instancedGeometry.maxInstancedCount = options.nPairs * 2;\r\n\r\n    // generate offsets\r\n    let sectionWidth = this.options.roadWidth / this.options.roadSections;\r\n    let aOffset = [];\r\n    let aMetrics = [];\r\n    let aColors = [];\r\n    for (let i = 0; i < options.nPairs; i++) {\r\n      let radius = Math.random() * 0.1 + 0.1;\r\n      // Give it some randomness but keep it over length *0.02\r\n      let length =\r\n        Math.random() * options.length * 0.08 + options.length * 0.02;\r\n\r\n      const rcolor = pickRandom(options.colors);\r\n    //   console.log(rcolor);\r\n      let c2 = (new THREE.Color(rcolor).toArray());\r\n    //   console.log(c2);\r\n      aColors.push(...c2);     \r\n      aColors.push(...c2);     \r\n      aMetrics.push(radius, length,radius, length);\r\n      \r\n\r\n      // 1a. Get lane index\r\n      // instead of random, keep lights per lane constent.\r\n      let section = i % 3;\r\n\r\n      // 1b. Get lane center pos\r\n      let sectionX =\r\n        section * sectionWidth - options.roadWidth / 2 + sectionWidth / 2;\r\n\r\n      let carWidth = 0.5 * sectionWidth;\r\n      let offsetX = 0.5 * Math.random();\r\n      let offsetY = radius * 1.3;\r\n      let offsetZ = Math.random() * this.options.length;\r\n\r\n      aOffset.push(sectionX - carWidth / 2 + offsetX);\r\n      aOffset.push(offsetY);\r\n      aOffset.push(-offsetZ);\r\n\r\n      aOffset.push(sectionX + carWidth / 2 + offsetX);\r\n      aOffset.push(offsetY);\r\n      aOffset.push(-offsetZ);\r\n    }\r\n    // console.log(\"colors\", aColors);\r\n\r\n    instancedGeometry.setAttribute(\r\n      \"aOffset\",\r\n      new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 3, false)\r\n    );\r\n    instancedGeometry.setAttribute(\r\n      \"aMetrics\",\r\n      new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false)\r\n    );\r\n    instancedGeometry.setAttribute(\r\n        \"aColors\",\r\n        new THREE.InstancedBufferAttribute(new Float32Array(aColors), 3, false)\r\n      );\r\n\r\n    let material = new THREE.ShaderMaterial({\r\n        fog: true,\r\n      fragmentShader: this.fragmentShader,\r\n      vertexShader: this.vertexShader,\r\n      transparent: true,\r\n      side: THREE.DoubleSide,\r\n      uniforms: {\r\n          ...THREE.UniformsUtils.merge( [\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ]\r\n      ] ),\r\n        uTime: new THREE.Uniform(0.0),\r\n        uSpeed: new THREE.Uniform(options.speed || 1.0),\r\n        uColor: new THREE.Uniform(new THREE.Color(options.color)),\r\n        uTravelLength: new THREE.Uniform(options.length),\r\n        ...this.options.distortion.uniforms     \r\n      },\r\n    });\r\n\r\n    material.onBeforeCompile = shader => {\r\n        shader.vertexShader = shader.vertexShader.replace(\r\n          \"#include <getDistortion_vertex>\",\r\n          this.options.distortion.vshader\r\n        );\r\n      };\r\n  \r\n\r\n    //material = new THREE.MeshBasicMaterial({ color: \"red\" });\r\n    //material.wireframe = true;\r\n    let mesh = new THREE.Mesh(instancedGeometry, material);\r\n    mesh.frustumCulled = false;\r\n    this.mesh = mesh;\r\n    //mesh.position.z = -15;\r\n \r\n    this.app.scene.add(mesh);\r\n  }\r\n\r\n  update(time) {\r\n    this.mesh.material.uniforms.uTime.value = time;    \r\n  }\r\n}\r\n","import * as THREE from \"three\";\r\n\r\n\r\n\r\nexport class Road {\r\n    constructor(app, options) {\r\n      this.app = app;\r\n      this.options = {\r\n        ...options,\r\n      };\r\n  \r\n      this.fragmentShader = `\r\n      uniform vec3 uColor;\r\n      void main(){\r\n          gl_FragColor = vec4(uColor,1.);\r\n      }\r\n  `;\r\n      this.vertexShader = `\r\n      uniform float uTime;\r\n\r\n      #include <getDistortion_vertex>\r\n      uniform float uTravelLength;\r\n      void main(){\r\n          vec3 transformed = position.xyz;\r\n          float progress = (transformed.y + uTravelLength / 2.) / uTravelLength;\r\n          vec3 distortion  = getDistortion(progress);\r\n          transformed.x += distortion.x;\r\n            transformed.z += distortion.y;\r\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed.xyz, 1.);\r\n      }\r\n  `;\r\n    }\r\n  \r\n    init() {\r\n      const options = this.options;\r\n  \r\n      const geometry = new THREE.PlaneBufferGeometry(\r\n        options.width,\r\n        options.length,\r\n        20,\r\n        200\r\n      );\r\n  \r\n      let material = new THREE.ShaderMaterial({\r\n        fragmentShader: this.fragmentShader,\r\n        vertexShader: this.vertexShader,\r\n        uniforms: {\r\n            uTime: new THREE.Uniform(0),\r\n          uColor: new THREE.Uniform(new THREE.Color(\"#000000\")),\r\n          uTravelLength: new THREE.Uniform(options.length),\r\n          ...this.options.distortion.uniforms,\r\n        },\r\n      });\r\n\r\n      material.onBeforeCompile = shader => {\r\n        shader.vertexShader = shader.vertexShader.replace(\r\n          \"#include <getDistortion_vertex>\",\r\n          this.options.distortion.vshader\r\n        );\r\n      };\r\n  \r\n      //material = new THREE.MeshBasicMaterial({color: \"red\"});\r\n      \r\n      const mesh = new THREE.Mesh(geometry, material);\r\n      this.mesh = mesh;\r\n      mesh.rotation.x = -Math.PI / 2;\r\n      mesh.position.z = -options.length / 2;\r\n  \r\n      this.app.scene.add(mesh);\r\n    }\r\n\r\n    update(time) {\r\n        this.mesh.material.uniforms.uTime.value = time;    \r\n      }\r\n  }","import * as THREE from \"three\";\r\n\r\n\r\nconst distortion_uniforms = {\r\n    uDistortionX: new THREE.Uniform(new THREE.Vector2(80, 3)),\r\n    uDistortionY: new THREE.Uniform(new THREE.Vector2(-40, 2.5))\r\n  };\r\n  \r\n  const distortion_vertex = `\r\n  #define PI 3.14159265358979\r\n    uniform vec2 uDistortionX;\r\n    uniform vec2 uDistortionY;\r\n  \r\n      float nsin(float val){\r\n      return sin(val) * 0.5+0.5;\r\n      }\r\n    vec3 getDistortion(float progress){\r\n          progress = clamp(progress, 0.,1.);\r\n          float xAmp = uDistortionX.r;\r\n          float xFreq = uDistortionX.g;\r\n          float yAmp = uDistortionY.r;\r\n          float yFreq = uDistortionY.g;\r\n          return vec3( \r\n              xAmp * nsin(progress* PI * xFreq   - PI / 2.) ,\r\n              yAmp * nsin(progress * PI *yFreq - PI / 2.  ) ,\r\n              0.\r\n          );\r\n      }\r\n  `;\r\n  \r\n  export const distortion1 = {\r\n    uniforms: distortion_uniforms,\r\n    vshader: distortion_vertex\r\n  };","import \"./style.css\";\r\n\r\n//import './style.css'\r\nimport * as THREE from \"three\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\n//import '../shared/OrbitControls.js'\r\nimport * as dat from \"dat.gui\";\r\n\r\nimport textureUrl from \"./texture.jpg\";\r\nimport displacementUrl from \"./r2.png\";\r\nimport alphaUrl from \"./b2.png\";\r\n\r\n\r\n// import { shader as frag } from \"./noise.frag\";\r\n// import { shader as vertex } from \"./noise.vert\";\r\n\r\n// const loader = new THREE.TextureLoader();\r\n// const texture = loader.load(textureUrl);\r\n// const displacement = loader.load(displacementUrl);\r\n// const alphaMap = loader.load(alphaUrl);\r\n\r\n// // Debug\r\n// const gui = new dat.GUI();\r\n\r\n// let config = {\r\n//   color: \"#00d1ff\",\r\n//   light: {\r\n//     x: 0,\r\n//     y: 0,\r\n//     z: 0,\r\n//   },\r\n//   reactToMouse: false,\r\n// };\r\n\r\n// // gui.add(config, \"reactToMouse\")\r\n\r\n// // Canvas\r\n// const canvas = document.querySelector(\"canvas\");\r\n\r\n// // Scene\r\n// const scene = new THREE.Scene();\r\n\r\n// // Objects\r\n// let gsize = 16 * 12;\r\n// const scaleUp = 64.0;\r\n// const geometry = new THREE.PlaneBufferGeometry(gsize, gsize, scaleUp, scaleUp);\r\n\r\n// // Materials\r\n// const material = new THREE.ShaderMaterial({\r\n//   uniforms: {\r\n//     uTime: { value: 0.0 },\r\n//     uResolution: { type: \"v2\", value: new THREE.Vector2() },\r\n//     alphaMap: { type: \"t\", value: alphaMap },\r\n//     scaleUp: { value: scaleUp },\r\n//   },\r\n//   transparent: true,\r\n//   depthTest: false,\r\n//   fragmentShader: frag,\r\n//   vertexShader: vertex,\r\n//   alphaMap,\r\n// });\r\n// material.uniforms.uResolution.value.x = window.innerWidth;\r\n// material.uniforms.uResolution.value.y = window.innerHeight;\r\n\r\n// // Mesh\r\n// const plane = new THREE.Mesh(geometry, material);\r\n// plane.rotation.x = 181;\r\n// plane.position.z = 2;\r\n// scene.add(plane);\r\n\r\n// /**\r\n//  * Sizes\r\n//  */\r\n// const sizes = {\r\n//   width: window.innerWidth,\r\n//   height: window.innerHeight,\r\n// };\r\n\r\n// window.addEventListener(\"resize\", () => {\r\n//   // Update sizes\r\n//   sizes.width = window.innerWidth;\r\n//   sizes.height = window.innerHeight;\r\n\r\n//   // Update camera\r\n//   camera.aspect = sizes.width / sizes.height;\r\n//   camera.updateProjectionMatrix();\r\n\r\n//   // Update renderer\r\n//   renderer.setSize(sizes.width, sizes.height);\r\n//   renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n// });\r\n\r\n// /**\r\n//  * Camera\r\n//  */\r\n// // Base camera\r\n// const camera = new THREE.PerspectiveCamera(\r\n//   75,\r\n//   sizes.width / sizes.height,\r\n//   1,\r\n//   3000\r\n// );\r\n// camera.position.x = 0;\r\n// camera.position.y = 1;\r\n// camera.position.z = 25;\r\n// scene.add(camera);\r\n\r\n// /**\r\n//  * Renderer\r\n//  */\r\n// const renderer = new THREE.WebGLRenderer({\r\n//   canvas: canvas,\r\n//   antialias: true,\r\n// });\r\n// renderer.setSize(sizes.width, sizes.height);\r\n// renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n\r\n// /**\r\n//  * Controls\r\n//  */\r\n// const controls = new OrbitControls(camera, renderer.domElement);\r\n// controls.enableDamping = true;\r\n// //controls.autoRotate = true;\r\n\r\n// const clock = new THREE.Clock();\r\n\r\n// const tick = () => {\r\n//   const elapsedTime = clock.getElapsedTime();\r\n//   plane.material.uniforms.uTime.value = elapsedTime;\r\n\r\n//   // Update Orbital Controls\r\n//   controls.update();\r\n//   // Render\r\n//   renderer.render(scene, camera);\r\n\r\n//   // Call tick again on the next frame\r\n//   window.requestAnimationFrame(tick);\r\n// };\r\n\r\n// tick();\r\n\r\nimport { BasicThreeDemo } from \"./BasicThreeDemo\";\r\nimport { CarLights } from \"./CarLights\";\r\nimport { Road } from \"./Road\";\r\nimport {distortion1 as distortion} from \"./effects\";\r\n\r\nexport class App extends BasicThreeDemo {\r\n  constructor(inoptions) {\r\n    const options = {\r\n      container: document.getElementById(\"container\"),\r\n      length: 400,\r\n      width: 20,\r\n      roadWidth: 9,\r\n      islandWidth: 2,\r\n      nPairs: 100,\r\n      roadSections: 3,\r\n      color: \"#111111\",\r\n      distortion,\r\n      ...inoptions,\r\n      \r\n    };\r\n    super(options.container);\r\n    this.options = options;\r\n\r\n\r\n    this.camera.position.z = 6;\r\n    this.camera.position.y = 7;\r\n    this.camera.position.x = 0;\r\n\r\n\r\n    let colors1 = [\"#ff0000\", \"#00ff00\", \"#0000ff\"];\r\n    let colors2 = [\"#ff0000\", \"#00ff00\", \"#0000ff\"];\r\n\r\n    colors1 = [\"#fbc50b\", \"#de5d00\", \"#f9f5d6\"];\r\n    colors2 = [\"#eb6333\", \"#b1d5de\", \"#182c37\"];\r\n\r\n    colors1 = [\"#0CECDD\", \"#FFF338\", \"#FF67E7\", \"#C400FF\"];\r\n    colors2 = [\"#0E185F\", \"#2FA4FF\", \"#00FFDD\", \"#E8FFC2\"];\r\n\r\n    this.road = new Road(this, options);\r\n    this.leftLights = new CarLights(this, {...options, colors:colors1, color: 0x00ff2a, speed: 30});\r\n    this.rightLights = new CarLights(this, {...options, colors:colors2, color: 0xff2a2a, speed: -30.0});\r\n\r\n    const c = new THREE.Color(\"black\");\r\n    \r\n\r\n    this.scene.background = c;\r\n  }\r\n\r\n  init() {\r\n    this.road.init();\r\n    this.leftLights.init();\r\n    this.leftLights.mesh.position.setX(this.options.roadWidth/2 + this.options.islandWidth /2);\r\n    \r\n    this.rightLights.init();\r\n    this.rightLights.mesh.position.setX(-this.options.roadWidth/2 - this.options.islandWidth /2);\r\n\r\n    \r\n\r\n    this.tick();\r\n  }\r\n\r\n  update(delta) {\r\n    let time = this.clock.elapsedTime;\r\n    this.road.update(time);\r\n    this.leftLights.update(time);\r\n    this.rightLights.update(time);\r\n  }\r\n}\r\n\r\n\r\n\r\nconst a = new App();\r\na.init();\r\n"],"names":["THREE.WebGLRenderer","THREE.PerspectiveCamera","THREE.Scene","THREE.Clock","THREE.LineCurve3","THREE.Vector3","THREE.TubeBufferGeometry","THREE.InstancedBufferGeometry","THREE.Color","THREE.InstancedBufferAttribute","THREE.ShaderMaterial","THREE.DoubleSide","THREE.UniformsUtils","THREE.UniformsLib","THREE.Uniform","THREE.Mesh","THREE.PlaneBufferGeometry","THREE.Vector2","distortion"],"mappings":"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"}